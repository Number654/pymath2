    Проект "Pymath" - это небольшой инструмент, расширяющий встроенные математические инструменты Python.

Обновление 2.0 вышло!

    В этом обновлении:
        1. Исправление багов и ошибок
        2. Улучшен и расширен функционал инструмента
        3. В проект встроены небольшие встроенные приложения,
          такие как стрелочные часы или текстовый редактор
        4. Добавлен новый пакет для геометрических вычислений
    Подробности о новостях обновления 2.0 указаны в файле "whatsnew-ru.txt".


Инструкция по использованию

    Оглавление:
        1. Глава I. Основной функционал................................................................183
            1.1. Файл "pymath.py" - основные функции...................................................187
                1.1.1. Проверка числа на нечетность....................................................189
                1.1.2. Проверка числа на составное.....................................................191
                1.1.3. Проверка числа на положительность...............................................193
                1.1.4. Проверка числа на злое..........................................................195
                1.1.5. Перемножение нескольких чисел...................................................198
                1.1.6. Нахождение кратных числа........................................................201
                1.1.7. Нахождение делителей числа......................................................204
                1.1.8. Нахождение НОК нескольких чисел.................................................206
                1.1.9. Нахождение НОД нескольких чисел.................................................209
                1.1.10. Разложение числа на простые множители..........................................212
                1.1.11. Наглядное представление результата разложения числа на простые множители.......219
                1.1.12. Представление числа в виде суммы разрядных слагаемых...........................222
                1.1.13. Генерация таблицы степеней целых чисел из диапазона............................225
                1.1.14. Нахождение среднего арифметического нескольких чисел...........................228
                1.1.15. Нахождение корня n-ой степени..................................................232
                1.1.16. Арккотангенс...................................................................235
                1.1.17. Улучшенное деление с остатком..................................................237
                1.1.18. Нахождение среднего геометрического нескольких чисел...........................241
                1.1.19. Нахождение медианы нескольких чисел............................................244
            1.2. Файл "fractions.py" - инструменты для работы с дробями................................247
                1.2.1. Класс "Fraction" - обыкновенные дроби...........................................249
                    1.2.1.1. Проверка дроби на смешанное число.........................................257
                    1.2.1.2. Проверка на неправильную дробь............................................259
                    1.2.1.3. Проверка дроби на типичность..............................................261
                    1.2.1.4. Проверка дроби на сократимость............................................263
                    1.2.1.5. Преобразование смешанного числа в неправильную дробь......................264
                    1.2.1.6. Преобразование неправильной дроби в смешанное число.......................268
                    1.2.1.7. Сокращение дроби..........................................................272
                    1.2.1.8. Обращение дроби...........................................................274
                    1.2.1.9. Приведение дроби в десятичную.............................................275
                    1.2.1.10. Проверка дроби на переводимость в десятичную.............................278
                    1.2.1.11. Упрощение знаков дроби...................................................280
                1.2.2. Класс "LiteralFraction" - дроби с буквенными выражениями........................288
                    1.2.2.1. Конкатенация выражений в числителе........................................300
                    1.2.2.2. Конкатенация выражений в знаменателе......................................303
                1.2.3. Класс "Double" - десятичные дроби большой точности..............................306
                    1.2.3.1. Округление десятичной дроби до нужной точности............................316
                1.2.4. Класс "PeriodicFraction" - периодические дроби..................................328
                    1.2.4.1. Переведение периодической дроби в обыкновенную............................338
                    1.2.4.2. Проверка периодической дроби на чистоту...................................341
                1.2.5. Функции модуля "fractions"......................................................344
                    1.2.5.1. Проверка строки на содержание десятичной дроби............................345
                    1.2.5.2. Преобразование целого числа в обыкновенную неправильную дробь.............348
                    1.2.5.3. Преобразование типа "float" в обыкновенную дробь..........................351
                    1.2.5.4. Преобразование списка строк с дробями в список объектов типа "Fraction"...354
                    1.2.5.5. Преобразование любого числового объекта в обыкновенную дробь..............357
                    1.2.5.6. Приведение списка дробей к наименьшему общему знаменателю.................365
                    1.2.5.7. Сортировка списка дробей..................................................371
                    1.2.5.8. Решение выражения в строке с обыкновенным дробями.........................374
            1.3. Файл "equations.py" - решение уравнений...............................................377
                1.3.1. Класс "SuperSymbol" - неизвестная буква в уравнении.............................383
                    1.3.1.1. Проверка на возможность решения уравнения.................................393
                    1.3.1.2. Решение уравнения с переносом слагаемых...................................396
                    1.3.1.3. Вычисление значения левой части уравнения по значению переменной..........400
                1.3.2. Класс "LinearSymbol" - буква для использования в линейных уравнениях............416
                1.3.3. Класс "FractionalSymbol" - буква для использования в дробных уравнениях.........426
                1.3.4. Класс "Symbol" - буква для использования во всех уравнениях.....................436
                1.3.5. Класс "SuperDoubleSymbol" - (суперкласс) уравнение с 2 неизвестными.............447
                1.3.6. Класс "DoubleSymbol" - уравнение с двумя неизвестными...........................469
                    1.3.6.1. Выражение первого неизвестного через второе...............................479
                1.3.7. Класс "TwoSidedDoubleSymbol" - уравнение с 2 неизвестными с переносом слагаемых.484
                1.3.8. Класс "EqSystem" - система уравнений............................................502
                    1.3.8.1. Решение системы уравнений.................................................517
                1.3.9. Класс "TransferEqSystem" - система уравнений с переносом слагаемых..............522
                    1.3.9.1. Решение системы уравнений.................................................538
            1.4. Файл "roman.py" - работа с римскими числами...........................................546
                1.4.1. Перевод арабского числа в римское...............................................549
                1.4.2. Перевод римского числа в арабское...............................................552
            1.5. Файл "scale.py" - вычисления с масштабом..............................................556
                1.5.1. Класс "Scale" - масштаб.........................................................556
                    1.5.1.1. Перевод масштаба в обыкновенную дробь.....................................565
                    1.5.1.2. Перевод численного масштаба в именованный.................................568
                    1.5.1.3. Получение расстояния на карте.............................................573
                    1.5.1.4. Получение расстояния на местности.........................................576
            1.6. Файл "numeric_system.py" - перевод единиц измерения...................................582
                1.6.1. Перевод единиц измерения длины..................................................587
                1.6.2. Перевод единиц измерения площади................................................592
                1.6.3. Перевод единиц измерения объема.................................................598
                1.6.4. Перевод единиц измерения времени................................................604
                1.6.5. Перевод единиц измерения углов..................................................609
                1.6.6. Перевод единиц измерения массы..................................................613
                1.6.7. Первеод единиц измерения напряжения.............................................617
                1.6.8. Перевод единиц измерения сопротивления..........................................621
                1.6.9. Перевод единиц измерения объема информации......................................625
                1.6.10. Перевод единиц измерения емкости конденсатора..................................629
                1.6.11. Перевод единиц измерения силы тока.............................................633
                1.6.12. Перевод единиц измерения мощности..............................................637
                1.6.13. Функция для осуществления перевода.............................................641
                1.6.14. Перевод единиц измерения скорости..............................................647
        2. Глава II. Шифрование простыми шифрами.......................................................663
            2.1. Файл "cipher.py" - алгоритмы шифрования...............................................674
                2.1.1. Класс "CaesarCipher" - шифр Цезаря..............................................675
                    2.1.1.1. Получение исходной строки.................................................686
                    2.1.1.2. Зашифровать исходную строку...............................................688
                    2.1.1.3. Расшифровать исходную строку..............................................691
                2.1.2. Класс "VigenereCipher" - шифр Виженера..........................................697
                    2.1.2.1. Получение исходной строки.................................................709
                    2.1.2.2. Зашифровать исходную строку...............................................711
                    2.1.2.3. Расшифровтаь исходную строку..............................................713
                2.1.3. Класс "AtbashCipher" - шифр Атбаш...............................................716
                    2.1.3.1. Получение исходной строки.................................................727
                    2.1.3.2. Зашифровать исходную строку...............................................729
                    2.1.3.3. Расшифровать исходную строку..............................................731
                2.1.4. Класс "EnigmaCipher" - шифр машинки Энигма......................................734
                    2.1.4.1. Шифрование и расшифровка данных...........................................746
        3. Глава III. Геометрические фигуры............................................................751
            3.1. Файл "shapes.py" - вычисления с геометрическими фигурами..............................755
                3.1.1. Класс "Shapes" - суперкласс всех классов фигур..................................757
                3.1.2. Класс "Angle" - угол............................................................766
                    3.1.2.1. Изменение градусной меры..................................................777
                3.1.3. Класс "Line" - прямая...........................................................781
                    3.1.3.1. Добавление точки..........................................................791
                    3.1.3.2. Удаление точки............................................................794
                3.1.4. Класс "Segment" - отрезок.......................................................798
                    3.1.4.1. Вычисление длины..........................................................810
                    3.1.4.2. Получение координат середины..............................................812
                3.1.5. Класс "Ray" - луч...............................................................815
                3.1.6. Класс "Ellipse" - эллипс........................................................826
                    3.1.6.1. Вычисление площади........................................................837
                    3.1.6.2. Вычисление длины..........................................................839
                    3.1.6.3. Получене координат точки, лежащей на эллипсе..............................841
                3.1.7. Класс "Circle" - круг...........................................................846
                    3.1.7.1. Вычисление длины хорды....................................................854
                3.1.8. Класс "RegularPolygon" - правильный многоугольник...............................858
                    3.1.8.1. Вычисление площади........................................................868
                    3.1.8.2. Вычисление периметра......................................................870
                3.1.9. Класс "IrregularPolygon" - неправильный многоугольник...........................873
                    3.1.9.1. Вычисление периметра......................................................884
            3.2. Файл "impossible_square.py" - невозможный квадрат.....................................888
                3.2.1. Класс "ImpossibleSquare" - невозможный квадрат..................................889
                    3.2.1.1. Отрисовка квадрата........................................................908
            3.3. Файл "plot.py" - построение графиков..................................................915
                3.2.1. Класс "Graph" - формула графика.................................................916
                    3.2.1.1. Отрисовка графика.........................................................926
                3.2.2. Класс "Plotter" - координатная плоскость........................................930
                    3.2.2.1. Размещение на окне........................................................946
                    3.2.2.2. Добавить график...........................................................948
                    3.2.2.3. Удалить график............................................................952
                    3.2.2.4. Очистка плоскости.........................................................954
                    3.2.2.5. Нумерация осей............................................................956
                    3.2.2.6. Отрисовка сетки...........................................................959
                    3.2.2.7. Отрисовка графиков........................................................962
            3.4. Файл "pie_chart.py" - круговые диаграммы..............................................971
                3.3.1. Класс "PieChart" - круговая диаграмма...........................................972
                    3.3.1.1. Отрисовка области диаграммы...............................................989
                3.3.2. Класс "LegendLabel" - легенда диаграммы.........................................993
                    3.3.2.1. Отрисовка легенды.........................................................1013
        4. Глава IV. Встроенные утилиты................................................................1020
            4.1. Приложение "Часы".....................................................................1024
            4.2. Приложение "Текстовый редактор".......................................................1034
                4.2.1. Дополнения......................................................................1041
                    4.2.1.1. Сохранение в PDF..........................................................1042
                    4.2.1.2. Раскраска текста..........................................................1045
                    4.2.1.3. Отмена раскраски текста...................................................1050
                4.2.2. Горячие клавиши.................................................................1053
            4.3. Приложение "Графика"..................................................................1074
                4.3.1. Рисование правильных фигур......................................................1077
                4.3.2. Сохранение рисунка..............................................................1078
                4.3.3. Открытие рисунка................................................................1081
                4.3.4. Изменение размера клетки........................................................1083
            4.4. Приложение "Графопостроитель".........................................................1087
        5. Глава V. Особенности импорта................................................................1095


    Глава I. Основной функционал
        В проекте "Pymath" главным пакетом является пакет с названием "core".
        Он содержит несколько файлов, о котором в этой главе пойдет речь.

        Начнем с главного файла - "pymath.py", в котором содержится основной
        функционал инструмента. Он содержит следующие функции:
            1. Чтобы узнать, является ли число нечетным, используйте функцию "is_odd()".
              Она принимает один аргумент: num - число, которое вы хотите проверить.
            2. Чтобы узнать, является ли число простым, используйте функцию "is_simple()".
              Она принимает один аргумент: num - число, которое вы хотите проверить.
            3. Чтобы узнать, положительное ли число, используйте функцию "is_positive()".
              Она принимает один аргумент: num - число, которое вы хотите проверить.
            4. Чтобы узнать, злое ли число (https://ru.wikipedia.org/wiki/%D0%97%D0%BB%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE),
              используйте функцию "is_evil()". Она принимает один аргумент: num - число,
              которое вы хотите проверить.
            5. Чтобы перемножить числа из итерируемого объекта, используйте функцию "multiply_all()".
              Она принимает один аргумент: _all - итерируемый объект, содержащий числа, которые Вы хотите
              перемножить.
            6. Чтобы найти кратные какого-либо числа, используйте функцию "multiplies()".
              Она принимает один обязательный аргумент: num - число, кратные которого Вы хотите найти
              и один необязательный: length - нужное Вам количество кратных, по умолчанию равное 10.
            7. Чтобы найти делители числа, используйте функцию "dividers()".
              Она принимает один аргумент: num - число, делители которого Вы хотите найти.
            8. Чтобы найти наименьшее общее кратное (НОК) нескольких чисел, используйте
              функцию "lcm()". Она принимает любое количество аргументов, которыми будут являться
              числа, НОК которых Вы хотите найти.
            9. Чтобы найти наибольший общий делитель (НОД) нескольких чисел, используйте
              функцию "gcd()". Она принимает любое количество аргументов, которыми будут являться
              числа, НОД которых Вы хотите найти.
            10. Чтобы разложить число на простые множители, используйте функцию "prime_factorization()".
              Она принимает один аргумент: num - число, которое вы хотите разложить на простые множители.
              Функция вернет два значения: первое - словарь, в котором содержится результат разложения
              построчно; второе - объект типа "collections.Counter", содержащий количество одинаковых
              простых множителей. Советую использовать функцию "visual_prime_factorization()"
              (см. пункт 11), так как она возвращает в качестве результата строку, содержащую
              более наглядный результат разложения.
            11. Чтобы получить наглядный результат разложения числа на простые множители, используйте
              функцию "visual_prime_factorization()". Она принимает в качестве аргумента результат
              функции "prime_factorization()" (см. пунк 10), преобразуя его в строку, удобную для понимания.
            12. Чтобы представить число в виде суммы разрядных слагаемых, используйте функцию
              "tens_factorization()". Она принимает один аргумент: num - число, которое Вы хотите
              обработать.
            13. Чтобы сгенереировать таблицу степеней в диапазоне натуральных чисел, используйте
              функцию "degree_table()". Она принимает два аргумента: degree - показатель
              степени, в которую следует возводить каждое из чисел таблицы; _range - диапазон целых
              чисел, которые следует использовать в таблице.
            14. Чтобы найти среднее арифметическое нескольких чисел, используйте функцию "average()".
              Она принимает один аргумент: nums - итереруемый объект, содержащий числа, среднее
              арифметическое которых Вы хотите найти.
            15. Чтобы найти корень числа n-ой степени, используйте функцию "root()". Она
              принимает один обязательный аргумент: x - число, корень которого Вы хотите найти
              и один необязательный: n - показатель корня, по умолчанию равный 2.
            16. Чтобы найти арккотангенс числа, используйте функцию "arcctg()". Она принимает
              один аргумент: x - число, арккотангенс которого Вы хотите найти.
            17. Чтобы выполнить деление с остатком, используйте функцию "better_divmod()".
              Она принимает два аргумента: x - делимое; y - делитель. Данная функция была создана,
              чтобы заменить встроенную функцию "divmod()", так как последняя округляля результат
              деления, чтобы получить цело число, вместо того, чтобы отсечь дробную часть результата.
            18. Чтобы найти среднее геометрическое нескольких чисел, используйте функцию "geometric_mean()".
              Она принимает один аргумент: nums - итереруемый объект, содержащий числа, среднее
              геометрическое которых Вы хотите найти.
            19. Чтобы найти медиану нескольких чисел, используйте функцию "median()". Она принимает один аргумент:
              array - итерируемый объект, содержащий числа, медиану которых Вы хотите найти.

        Файл "fractions.py" содержит инструменты для работы с обыкновенными дробями. В данном
        файле содержатся классы, а также некоторые функции. Начнем с классов:
            1. Класс "Fraction". Данный класс нужен, чтобы сохранить в переменной обыкновенную дробь.
              Создание экземпляра класса происходит следующим образом:
                  my_fraction = Fraction("5&2/3")
                Сначала идет целая часть (если есть), затем ставится знак "&", затем идет числитель
              дроби, после него стоит знак "/", в конце идет знаменатель дроби.
                С экземпляром класса можно производить все арифметические действия, а также
              возведение в степень с целым показателем. Кроме того, у класа "Fraction" есть
              следующие методы:
                  1. "Fraction.is_mixed_number()". Данный метод вернет True, если дробь является
                    смешанным числом (имеет целую часть).
                  2. "Fraction.is_improper()". Данный метод вернет True, если дробь является
                    неправильной.
                  3. "Fraction.is_typical()". Данный метод вернет True, если дробь не является
                    ни смешанным числом, ни неправильной дробью.
                  4. "Fraction.is_contract()". Данный метод вернет True, если дробь можно сократить.
                  5. "Fraction.format_to_improper_fraction()". Данный метод нужен, чтобы преобразовать
                    смешанное число в неправильную дробь. В случае, если дробь не смешанное число
                    или уже является неправильной, метод вернет копию дроби, которую Вы пытались
                    преобразовать.
                  6. "Fraction.format_to_mixed_number()". Данный метод нужен, чтобы преобразовать
                    неправильную дробь в смешанное число. В случае, если дробь уже смешанное число
                    или не является неправильной, метод вернет копию дроби, которую Вы пытались
                    преобразовать.
                  7. "Fraction.reduce()". При вызове данного метода произойдет сокращение дроби
                    до несократимой.
                  8. "Fraction.reverse()". Метод вернет дробь, обратную данной.
                  9. "Fraction.to_decimal()". Данный метод нужен, чтобы привести обыкновенную дробь
                    к десятичному знаменателю. При этом, если дробь невозможно обратить в десятичную,
                    метод вызовет исключение ValueError.
                  10. "Fraction.is_translatable_to_decimal()". Данный метод вернет True, если дробь
                    можно обратить в десятичную.
                  11. "Fraction.format_sign()". Данный метод служебный. Он вызывается в конструкторе
                    класса "Fraction", чтобы упростить знаки в числителе и знаменателе дроби. Например,
                    если и в числителе, и в знаменателе дроби отрицательные числа, то после упрощения
                    дробь будет положительной.
                Так же данный класс поддерживает переведение в тип int. Для этого нужно вызвать
              встроенную функцию int() и передаеть ей экземпляр класса "Fraction". При вызове данной
              функции произойдет отсечение дробной части.

            2. Класс "LiteralFraction". Данный класс нужен, чтобы сохранить в переменной
              обыкновенную дробь, числитель и/или знаменатель которой являются буквенными
              выражениями.
              Создание экземпляра класса происходит следующим образом:
                  my_fraction = LiteralFraction(("2a+5.5b", "6c-8a"))
                  В конструктор класса предается список или кортеж, в котором первый объект -
                строка, содержащая числитель дроби; второй - строка, содержащая знаменатель дроби.
                  Внимание! Данный класс не поддерживает смешанные числа.
              Данный класс не поддерживает арифметические действия. Числитель класса сохранен
              в переменной экземпляра "my_fraction.numerator", знаменатель в "my_fraction.denominator".
              Изменяя эти переменные, Вы изменяете выражения в дроби. Кроме того, в классе есть
              методы, позволяющие производить конкатенацию выражений:
                  1. "LiteralFraction.append_to_numerator()". Данный метод производит конкатенацию
                    выражений в числителе дроби и принимает один аргумент: string - буквенное
                    выражение, которое Вы хотите присоединить к выражению в числителе.
                  2. "LiteralFraction.append_to_denominator()". Данный метод производит конкатенацию
                    выражений в знаменателе дроби и принимает один аргумент: string - буквенное
                    выражение, которое Вы хотите присоединить к выражению в знаменателе.

            3. Класс "Double". Данный класс позволяет использовать числа с плавающей точкой
              большей точности. Ограничителями точности являются объем оперативной памяти и
              мощность процессора.
              Создание экземпляра класса происходит следующим образом:
                  my_fraction = Double("3.14159265358979323846")
                  В конструктор передается один аргумент: строка, содержащая десятичную дробь.
                Обратите внимание, что целая часть числа от дробной отделяется только точкой.
              Данный класс поддерживает все арифметические действия, так же, как и класс
              "Fraction". Ниже перечислены некоторые другие методы класса "Double":
                  1. "Double.round()". Данный метод округляет десятичную дробь до
                    нужной точности и принимает одини необязательный аргумент: accuracy - точность,
                    до которой следует округлять, по умолчанию - до целых. Округление происходит так
                    же, как и в случае со встроенным методом round(), о котором можно приочитать в
                    документации Python.
                Так же данный класс поддерживает переведение в тип int. Для этого нужно вызвать
              встроенную функцию int() и передаеть ей экземпляр класса "Double". При вызове данной
              функции произойдет отсечение дробной части.
                Так же есть возможность перевести тип "Double" в тип float. Для этого нужно вызвать
              встроенную функцию float() и передать ей ээкземпляр класса "Double". Внимание! При
              переведении в тип float возможна потеря точности.

            4. Класс "PeriodicFraction". Данный класс позволяет работать с периодическими дробями.
               Создание экземпляра класса происходит следующим образом:
                   my_fraction = PeriodicFraction("1.(3)")
                   В конструктор передается один аругмент: строка, содержащая периодическую дробь.
                 При этом, перед точкой стоит целая часть, затем точка, после нее идут цифры до периода
                 (если они есть), затем, в скобках стоят цифры в периоде.
                   Обратите внимание, что целая часть от дробной отделяется только точкой.
               Данный класс не поддерживает арифметические действия, однако, есть возможность перевести
               периодическую дробь в обыкновенную, и с ней производить арифметические действия. Ниже
               перечислены методы класса "PeriodicFraction":
                   1. "PeriodicFraction.to_ordinary()". Данный метод не принимает аргументов. Нужен
                     для переведения периодической дроби в обыкновенную. При вызове вернет экземпляр
                     класса "Fraction", содержащий результат переведения.
                   2. "PeriodicFraction.is_clean()". Данный метод вернет True, если периодическая
                     дробь является чистой, то есть не содержит цифр перед периодом.

        Также файл "fractions.py" содержит несколько функций для работы с дробями:
           1. Чтобы узнать, содержит ли строка число с плавающей точкой, используйте функцию "isfloat()".
             Она принимает один аргумент: string - строка, которую Вы хотите проверить. Функция вернет True,
             если строка содержит число с плавающей точкой.
           2. Чтобы преобразовать целое число (int) в обыкновенную неправильную дробь, используйте функцию
             "int2fraction()". Она принимает один аргумент: integer - целое число, которое Вы хотите
             преобразовать.
           3. Чтобы преобразовать число с плавающей точкой (float) в обыкновенную дробь, используйте функцию
             "float2ordinary()". Она принимает один аргумент: _float - число с плавающей точкой, которое
             Вы хотите преобразовать.
           4. Чтобы перобразовать список строк, содержащих дроби в список дробей типа "Fraction",
             используйте функцию "strings_list2fractions_list()". Она принимает один аргумент: my_list -
             итерируемый объект, в том числе список, который Вы хотите преобразовать. Обратите внимание,
             что строки в списке для преобразования должны иметь такую же структуру, как и те, что Вы
             передаете в конструктор класса "Fraction" (см. страницу ***).
           5. Чтобы преобразовать целое число (int) или число с плавающей точкой (float) в обыкновенную
             дробь, используйте функцию "to_fraction()". Данная функция по сути совмещает алгоритмы из функций
             "int2fraction()" и "float2ordinary()". Она принимает один аргумент: __obj - число, которое
             Вы хотите преобразовать. Если в качестве аргумента будет передан тип "Fraction", то есть не
             требующая преобразования обыкновенная дробь, функция вернет ее. Если аргумент не будет
             являться ни типом int, ни float, ни "Fraction", функция вернет None.
           6. Чтобы привести дроби к наименьшему общему знаменателю, используйте функцию
             "reduce_to_common_denominator()". Она принимает один аругмент: my_fractions - итерируемый
             объект, содержащий обыкновенные дроби ("Fraction"). Данная функция вернет список дробей с
             наименьшим общим знаменателем.
           7. Чтобы отсортировать список обыкновенных дробей, используйте функцию "sort_fractions()".
             Она принимает один обязательный аргумент: my_fractions - итерируемый объект, содержащий
             обыкновенные дроби ("Fraction"); и один необязвательный: reverse - аргумент, обозначающий
             порядок сортировки: True - по убыванию, False - по возрастанию; по умолчанию равный False.
             Данная функция вернет список отсортированных в заданном порядке обыкновенных дробей.
           8. Чтобы решить короткое выражение с обвкновенными дробями в строке, используйте функцию
             "solve_fraction_expr()". Она принимает один аргумент: expr - строка, содержащая выражение.
             Обратите внимание, что все обыкновенные дроби должны быть отделены от знаков арифметических
             действий пробелами и иметь такую же структуру, как строки, передаваемые в конструктор класса
             "Fraction" (см. страницу ***). Важно! Данная функция не поддерживает выражения со вложенными
             скобками.

        Файл "equations.py" содержит инструменты для работы с уравнениями. В данном фале находятся классы
        для решения уравнений и систем уравнений, перечисленные ниже:
            1. Класс "SuperSymbol". Данный класс нужен, чтобы сохранить в переменной неизвестную букву,
              затем произвести арифметические действия с ней, а затем решить. Это происходит следующим
              образом:
                  a = SuperSymbol(symbol="a")
                  a = 8-(2*a*5+3)
              Конструктор данного класса принимает один необязательный аргумент: symbol - буква,
              которую Вы хотите использовать в уравнении (по умолчанию "x").

              У данного класса, помимо методов для выполения арифметических действий есть и другие методы,
              перечисленные ниже:
                  1. "SuperSymbol.can_solve()". Данный принимает один аргумент: z - правая часть уравнения
                    (это может быть число или другой экзкмепляр класса SuperSymbol) и вернет True, если
                     у уравнения есть хотя бы одно решение.
                  2. "SuperSymbol.get()". Данный метод принимает один аргумент: z - правая часть уравнения.
                    При этом, если в качестве аргумента передать другой экземпляр класса SuperSymbol,
                    произойдет перенос слагаемых, а затем решения уравнения. Если у уравнения не окажется
                    решений, метод вернет None.
                  3. "SuperSymbol.post_symbol()". Данный метод принимает один аргумент: n - число, которое
                    нужно подставить вместо неизвестного в уравнении. Данный метод нужен для решения
                    числового выражения, которое получится при подстановки числа n в левую часть уравнения
                    вместо неизвестного.

              Внимание! Класс "SuperSymbol" является суперклассом всех классов для решения уравнений.
              Это означает, что у все подклассы будут устроены подобным этому классу образом.
              Так как подклассами данного класса являются линейные и дробные уравнения, в самом
              суперклассе не находятся алгоритмы их решения. Напрмер, в методе "SuperSymbol.get()"
              реализован только алгоритм переноса слагаемых. После выполнения этого алгоритма, метод
              передаст управление метлду из подкласса, который, в ссвою очередь, произведет решение
              уравнения. Если же перенос слагаемых не потребовался, метод веренет строку "continue",
              получив котороую, метод решения уравнения из подкласса выполнит это действие.
              Также в методе суперкласса "SuperSymbol.post_symbol()" отсутствует рализация, метод
              переопределен в подклассах и реализован.

            2. Класс "LinearSymbol". Данный класс является подклассом "SuperSymbol" (см. пункт 1). Он
              нужен для решения линейных уравнений. Создание экземпляра класса происходит
              так же, как и у "SuperSymbol":
                  a = SuperSymbol(symbol="a")
                  a = 8-(2*a*5+3)

              Как говорилось в пункте 1, "LinearSymbol" и другие подклассы имеют те же методы, что и
              "SuperSymbol". Это означает, что данным классом нужно пользоваться так же, как и классом
              "SuperSymbol".

            3. Класс "FractionalSymbol". Данный класс является подклассом "SuperSymbol" (см. пункт 1).
              Он нужен для решения дробных уравнений (в которых неизвестное в знаменателе). Создание
              экземпляра класса проичходит так же, как и у "SuperSymbol":
                  a = SuperSymbol(symbol="a")
                  a = 8-(2*a*5+3)

              Как говорилось в пункте 1, "LinearSymbol" и другие подклассы имеют те же методы, что и
              "SuperSymbol". Это означает, что данным классом нужно пользоваться так же, как и классом
              "SuperSymbol".

            4. Класс "Symbol". Данный класс является подклассом "SuperSymbol" (см. пункт 1). Он нужен
              для решения уравнений неопределенного вида (вид может переходить из линейного в дробный
              и обратно в процессе арифметических действий). Создание экзмемпляра класса происходит
              так же, как и y "SuperSymbol":
                  a = SuperSymbol(symbol="a")
                  a = 8-(2*a*5+3)

              Как говорилось в пункте 1, "LinearSymbol" и другие подклассы имеют те же методы, что и
              "SuperSymbol". Это означает, что данным классом нужно пользоваться так же, как и классом
              "SuperSymbol".

            5. Класс "SuperDoubleSymbol". Данный класс нужен для работы с уравнениями, в которых неизвестны
              два числа и используются в системах уравнений. Данный класс является подклассом "Symbol".
              Заметим, что суперклассом для "SuperDoubleSymbol" выбран именно класс "Symbol", так как
              не требуется определение вида уравнения.
              Создание экзмепляра класса происходит следующим образом:
                  eq = SuperDoubleSymbol(sub=True, symbol1="p", symbol2="q")
                  eq = 9-(2*eq+6-8*(eq-1))

              Конструкор класса "SuperDoubleSymbol" принимает три необязательных аргумента: sub - True,
              если нужно вычитать два неизвестных (второе из первого), по умолчанию False; symbol1 -
              буква, которой Вы хоите обозначить первое неизвестное, по умолчанию "x"; symbol2 - буква,
              которой Вы хотите обозначить второе неизвестное, по умолчанию "y".

              Класс "SuperDoubleSymbol" поддерживает арифметические действия, однако, если Вы попытаетесь
              вызвать метод "SuperDoubleSymbol.get()", он вызоыет исключение TypeError, так как уравнения
              с двумя неизвестными нельзя решить по отдельности - они используются только в системе
              уравнений.

              Внимание! Класс "SuperDoubleSymbol" является суперклассом всех классов для работы с
              уравнениями с двумя неизвестными. Это означает, что все его подклассы будут устроены
              подобным этому классу образом.

            6. Класс "DoubleSymbol". Данный класс является подклассом "SuperDoubleSymbol" (см. пункт 5).
              Он нужен для работы с уравнениями, в которых неизвестны два числа. Как говорилось в пункте
              выше, такие уравнения нельзя решить отдельно от системы уравнений. Создание экземпляра
              класса происходит следующим образом:
                  eq = DoubleSymbol(5, sub=True, symbol1="p", symbol2="q")
                  eq = 9-(2*eq+6-8*(eq-1))

              Конструктор класса принмает, помимо аргументов его суперкласса, обязательный аргумент
              z - правая часть уравнения (число).

              У данного класса есть 1 метод:
                  "DoubleSymbol.express_x()". Данный метод не принимает аргументов и нужен, чтобы выразить
                  первое неизвестное из уравнения. Метод вернет экземпляр класса "Symbol" - уравнение с
                  одним неизвестным, которое будет иметь букву аторого неизвестного.

            7. Класс "TwoSidedDoubleSymbol". Данный класс является подклассом "SuperDoubleSymbol"
              (см. пункт 5). Он нужен для работы с уравнениями, в которых неизвестны два числа, но
              с возможностью переноса слагаемых (только если в уравнении в обеих частях неизвестные).
              Для таких уравнений создан отдельный класс системы уравнений, о чем будет написано в
              следующих пунктах.

              Создание экземпляра класса происходит следующим образом:
                  eq = TwoSidedDoubleSymbol(sub=True, symbol1="p", symbol2="q")
                  eq = 9-(2*eq+6-8*(eq-1))

              Данный класс, в отличие от "DoubleSymbol" не имеет метода "express_x()". Так как в
              обеих частях такого уравнения находятся неизвестные, перенос слагаемых отдельно от
              системы уравнений осуществить не получится. Это происходит сразу при решении системы
              уравнений. Также, в классе "TwoSidedDoubleSymbol" не нужно сразу передавать правую
              часть, так как в конструктор класса для решения систем уравнений с перенеосом слагаемых
              передаются кортежи с двумя экземплярами класса "TwoSidedDoubleSymbol": один - левая часть;
              второй - правая.

            8. Класс "EqSystem". Данный класс нужен для решения систем уравнений. Создание экземпляра
              класса происходит следующим образом:
                eq1 = DoubleSymbol(7, sub=False, symbol1="x", symbol2="y")
                eq1.k2 = 5  # Коэффициент второго неизвестного теперь равен 5

                eq2 = DoubleSymbol(4, sub=True, symbol1="x", symbol2="y")
                eq2.k, eq2.k2 = (3, 2)  # Коэффициенты 1 и 2-го неизвестных равны 3 и 2 соответственно

                eq_system = EqSystem(eq1, eq2)

              Сначала нужно создать два экземпляра класса "DoubleSymbol", затем передать их в
              конструктор класса "EqSystem". Важно! Чтобы задать нужные коэффициенты неизвестным,
              обращайтесь к переменным экземпляра: k - коэффициент первого неизвестного; k2 -
              коэффициент второго неизвестного (по умолчанию все коэффициенты равны 1).

              У данного класса есть 1 метод:
                  "EqSystem.get()". Данный метод не принимает аргументов и нужен, чтобы решить систему
                  уравнений. Вернет словарь, в котором ключом является буква неизвестного, значением -
                  значение неизвестного.

            9. Класс "TransferEqSystem". Данный класс является подклассом класса "EqSystem" и нужен
              для решения систем уравнений с предварительным переносом слагаемых в этих уравнениях.
              Создание экземпляра класса происходит следующим образом:
                eq1_left = 3*TwoSidedDoubleSymbol(sub=True, symbol1="x", symbol2="y")
                eq1_left = eq1_left + 5*Symbol("x")  # Левая часть первого уравнения
                eq1_right = 2*(3*Symbol("x")-2)  # Правая часть первого уравнения

                # Левая часть второго уравнения
                eq2_left = 4*Symbol("x") - 2*TwoSidedDoubleSymbol(sub=False, symbol1="x", symbol2="y")
                eq2_right = 4 - 3*Symbol("y")  # Правая часть второго уравнения

                eq_system = TransferEqSystem((eq1_left, eq1_right), (eq2_left, eq2_right))

              В конструктор класса "TransferEqSystem" передается два кортежа, содержащих левую
              и правую часть уравнений.

              Данный класс имеет 1 метод:
                  "TransferEqSystem.get()". Данный метод не принимает аргументов и нужен для решения
                  системы уравнений. При вызове произойдет перенесение слагаемых в обоих уравнениях,
                  результатом будут уравнения с неизвестными только в левой части (экземпляры класса
                  "DoubleSymbol"), после этого на основе полученных данных будет создан экземпляр
                  класса "EqSystem" и выполнено решение системы уравнений. Метод вернет словарь,
                  в котором ключом является буква неизвестного, значением - значение неизвестного.

        Файл "roman.py" довольно небольшой - он содержит две функции для перевода арабских чисел
        в римские и наоборот. Заметим, что не все числа можно перевести в римские. Перевести можно
        только числа от 1 до 3999 включительно. Эти две функции описаны ниже:
            1. "arab2roman()". Данная функция нужна для перевода арабского числа в римское. Она
              принимает один аргумент: num - число (int), которое Вы хотите перевести. Функция
              возвращает строку str.
            2. "roman2arab()". Данная функция нужна для перевода римского числа в арабское. Она
              принимает один аргумент: num - строка с римским числом (str), которое Вы хоите
              перевести в арабское. Функция возвращает целое число int.

        Файл "scale.py" также довольно мал - он содержит один класс "Scale" для работы с масштабом.
        Создание экземпляра класса "Scale" происходит следующим образом:
            my_scale = Scale("1:50")  # В 1 см 50 см.

        Конструктор класса принимает один аргумент: scale - строка, содержащая масштаб. При этом,
        сначала пишется расстояние на карте (в см), затем двоеточие ":", затем расстояние на
        местности (в см).

        Класс "Scale" содержит следующие методы:
            1. "Scale.to_fraction()". Данный метод не принимает аргументов и нужен для перевода
              экземпляра класса "Scale" в тип "Fraction" (см. выше). При этом, в результате числителем
              дроби будет расстояние на карте (в см), а знаменателем - расстояние на местности (в см).
            2. "Scale.to_string()". Данный метод не принимает аргументов и нужен для перевода
              численного масштаба "Scale" в именованный масштаб (строку). Обратите внимание, что
              строка будет содержать единицы измерения на английском языке.
            3. "Scale.get_on_image()". Данный метод нужен для получения расстояния на карте по заданному
              расстоянию на местности. Например, если расстояние на местности равно 5 м, а масштаб
              равен 1:100, то расстояние на крате будет равно 5 см. Данный метод принимает один аргумент:
              real_distance - расстояние на местности в виде числа. Важно! Расстояние на местности должно
              быть задано в сантиметрах. Метод вернет тип Fraction, результат будет дан в сантиметрах.
            4. "Scale.get_real()". Данный метод нужен для получения расстояния на местности по заданному
              расстоянию на карте. Например, если расстояние на карте равно 2 см, а масштаб равен 1:100,
              то расстояние на местности равно 2 м. Данный метод принимает один аргумент:
              distance_on_image - расстояние на крате в виде числа. Важно! Расстояние на карте должно быть
              задано в сантиметрах. Метод вернет тип Fraction, результат будет дан в сантиметрах.

        Файл "numeric_system.py" содержит классы с константами для перевода из одной системы счисления в
        другую. Есть возможность переводить единицы длины, площади, объема, времени, единиц измерения
        углов, массы, электрического напряжения, сопротивления, объема инфромации, емкости конденсатора,
        силы тока, а также мощности.

        Константы для переведения единиц измерения длины находятся в классе "Length". Поддерживаемые
        единицы измерения длины указаны ниже.
            1. Метрические единицы измерения длины от нанометра до километра включительно
            2. Ярды, футы, дюймы, мили.

        Константы для переведения единиц измерения площади находятся в классе "Area". Поддерживаемые
        единицы измерения площади указаны ниже.
            1. Метрические единицы измерения площади от квадратного нанометра до квадартного километра
              включительно.
            2. Ары, гектары, квадратные ярды, квадратные футы, квадратные дюймы, квадратные мили.

        Константы для переведения единиц измерения объема находятся в классе "Volume". Поддерживаемые
        единицы измерения объема указаны ниже.
            1. Микролитры, миллилитры, литры, кубические миллиметры, кубичекские сантиметры, кубические
              метры, кубические километры.
            2. Кубические ярды, кубичексие футы, кубические дюймы, американские баррели.

        Константы для переведения единиц измерения времени находятся в классе "Time". Поддерживаемые
        единицы измерения времени указаны ниже.
            1. Метрические единицы измерени времени от наносекунды до секунды включительно.
            2. Минуты, часы, дни, недели, месяцы, годы, десятилетия, века.

        Константы для переведения единиц измерения углов находятся в классе "Angle". Поддерживаемые
        единицы измерения углов указаны ниже.
            1. Грады, градусы, радианы, тысячные, минуты дуги, секунды дуги.

        Константы для переведения единиц измерения массы находятся в классе "Mass". Поддерживаемые
        единицы измерения массы указаны ниже.
            1. Метрические единицы измерения массы от нанограмма до килотонны включительно.

        Константы для переведения единиц измерения электрического напряжения находятся в классе "Voltage".
        Поддерживаемые единицы измерения электрического напряжения указаны ниже.
            1. Метрические единицы измерения напряжения от пиковольта до теравольта включительно.

        Константы для переведения единиц измерения сопротивления находятся в классе "Resistance".
        Поддерживаемые единицы измерения сопротивления указаны ниже.
            1. Метрические единицы измерения сопротивления от микроома до мегаома включительно.

        Константы для переведения единиц измерения объема информации находятся в классе "InformationSize".
        Поддерживаемые единицы измерения объема инфромации указаны ниже.
            1. Единицы измерения объема инфромации от бита до петабайта включительно.

        Константы для переведения единиц измерения емкости конденсатора находятся в классе "Capacity".
        Поддерживаемые единицы измерения емкости конденсатора указаны ниже.
            1. Метрические единицы измерения емкости конденсатора от пикофарада до гигафарада включительно.

        Константы для переведения единиц измерения силы тока находятся в классе "Amperage". Поддерживаемые
        единицы измерения силы тока указаны ниже.
            1. Метрические единицы измерения силы тока от наноампер до килоампер включительно.

        Константы для переведения единиц измерения мощности находятся в классе "Power". Поддерживаемые
        единицы измерения мощности указаны ниже.
            1. Метрические единицы измерения мощности от пиковатт до петаватт включительно.

        Для того, чтобы перевести единицы измерения, файл "numeric_system.py" содержит функцию "convert()".
        Она приниимает два аргумента: formula - константа для перевода; x - число, указанное в той единице
        измерения, которую следует перевести в другую. При этом, дуступ к константе происходит следующим
        образом: Класс.КОНСТАНТА, где Класс - класс, содержащий константы для перевода единиц измерения
        величин, указанных выше; КОНСТАНТА - константа для перевода соответвственно.

        Также, в файле присуттсвует функция "convert_speed()". Данная функция нужна для перевода единиц
        измерения скорости. Формулы для перевода единиц измерения скорости отсутствуют в классах, так как
        они бы заняли слишком много места. Функция "convert_speed()" принимает два аргумента: speed1 -
        строка, содержащая скорость с числом для переведения; speed2 - строка, содержащая единицу измерения
        скорости, в которую  следует перевести число из первой строки. Пример использования:
            y = convert_speed("5 kilometers/hour", "meters/minute")

        Первая строка оформляется так: сначала идет число (int или float, допускается использование классов,
        реализующих числа, например, "Fraction"), затем через пробел идет единца измерения расстояния,
        причем та, которую поддерживает класс "Length" (на английском языке), затем знак "/" без пробелов,
        затем единица измерения времени, которую поджерживает класс "Time" (на английском языке).
        Вторая строка оформляется так: сначала идет единица измерения расстояния, которую поддерживает класс
        "Length" (на английском языке), затем знак "/", затем единица измерения времени, которую поддерживает
        класс "Time" (на английском языке).


    Глава II. Шифрование простыми шифрами
        В проекте "Pymath" также есть пакет "cipher". В данном пакете находятся инструменты для работы
        с простыми шифрами. В этой главе пойдет речь о данном пакете.

        Начнем с файла "alphabet.py". Он содержит класс "Alphabet", который нужен для создания алфавита
        шифрования. Создание экземпляра класса происходит следующим образом:
            alphabet = Alphabet("abcdefghijklmnopqrstuvwxyz", 4)

        Конструктор класса принмает два аргумента: symbols - строка, содержащая буквы алфавита;
        most_used - индекс самой распространенной буквы алфавита, начиная с нуля.

        В файле "cipher.py" содержатся алгоритмы шифрования в виде классов. Файл содержит классы:
            1. "CaesarCipher". Данный класс реализует алгоритм шифрования шифром Цезаря. Создание
              экземпляра класса происходит следующим образом:
                  alphabet = Alphabet("abcdefghijklmnopqrstuvwxyz", 4)  # Создаем латинский алфавит
                  my_cipher = CaesarCipher("Lorem ipsum dolor, sit amet.", alphabet)

              Конструкор класса принмает один обязательный аргумент: data - строка, содержащая
              данные, которые Вы хотите расшифровать или зашифровать; и один необязательный -
              _alphabet - алфавит, использующийся в строке, по которому будет производиться
              шифрование (по умолчанию - латинский).

              Класс "CaesarCipher" содержит следующие методы:
                  1. "CaesarCipher.to_string()". Данный метод не принимает аргументов, вернет строку
                    с данными, переданными в конструктор класса (см. выше).
                  2. "CaesarCipher.encrypt()". Данный метод принимает один аргумент: key - ключ
                    (целое число int), по которому будет производиться шифрование. Метод вернет
                    зашифрованные данные в виде строки.
                  3. "CaesarCipher.decrypt()". Данный метод принимает один необяхательный аргумент: key -
                    ключ (целое число int), по которому будет производиться дешифровка. Если ключ не указан,
                    метод попытается выполнить частотный анализ, чтобы получить ключ, а затем расшифрует
                    данные. Обратите внимание, что дешифровка без ключа может не сработать, если строка
                    с зашифрованными данными слишком мала.

            2. "VigenereCipher". Данный класс реализует алгоритм шифрования шифром Виженера. Создание
              экземпляра класса происходит следующим образом:
                  alphabet = Alphabet("abcdefghijklmnopqrstuvwxyz", 4)  # Создаем латинский алфавит
                  my_cipher = VigenereCipher("Lorem ipsum dolor, sit amet.", alphabet)

              Конструкор класса принмает два обязательных аргумента: data - строка, содержащая данные,
              которые Вы хотите расшифровать или зашифровать; key - ключ (строка), по которому в
              дальнейшем будут производиться шифрование и дешифрование; и один необязательный -
              _alphabet - алфавит, использующийся в строке, по которому будет производиться шифрование
               (по умолчанию - латинский).

              Класс "VigenereCipher" содержит следующие методы:
                  1. "VigenereCipher.to_string()". Данный метод не принимает аргументов, вернет строку
                    с данными, переданными в конструктор класса (см. выше).
                  2. "VigenereCipher.encrypt()". Данный метод не принимает аргументов, веренет строку с
                    зашифрованными данными.
                  3. "VigenereCipher.decrypt()". Данный метод не принимает аргументов, вернет строку с
                    рашифрованными данными.

            3. "AtbashCipher". Данный класс реализует алгоритм шифрования шифром Атбаш. Создание
              экземпляра класса происходит следующим образом:
                  alphabet = Alphabet("abcdefghijklmnopqrstuvwxyz", 4)  # Создаем латинский алфавит
                  my_cipher = AtbashCipher("Lorem ipsum dolor, sit amet.", alphabet)

              Конструкор класса принмает один обязательный аргумент: data - строка, содержащая
              данные, которые Вы хотите расшифровать или зашифровать; и один необязательный -
              _alphabet - алфавит, использующийся в строке, по которому будет производиться
              шифрование (по умолчанию - латинский).
              
              Класс "AtbashCipher" содержит следующие методы:
                  1. "AtbashCipher.to_string()". Данный метод не принимает аргументов, вернет строку
                    с данными, переданными в конструктор класса (см. выше).
                  2. "AtbashCipher.encrypt()". Данный метод не принимает аргументов, веренет строку с
                    зашифрованными данными.
                  3. "AtbashCipher.decrypt()". Данный метод не принимает аргументов, вернет строку с
                    рашифрованными данными.

            4. "EnigmaCipher". Данный класс реализует алгоритм шифрования шифровальной машины "Энигма".
              Обратите внимание, что комбинации на всех роторах заданы так же, как и в шифровальной
              машине по умолчанию.
              Создание экземпляра класса происходит следующим образом:
                  my_enigma = EnigmaCipher("Lorem ipsum dolor, sit amet.", rotor1="P",
                                           rotor2="V", rotor3="S")

              Конструктор класса принимает один обязательный аргумент: data - строка, содержащая
              данные, которые Вы хотите расшифровать или зашифровать; и три необязательных аргумента:
              rotor1 - буква, заданная на I-роторе; rotor2 - буква, заданная на II-роторе; rotor3 -
              буква, заданная на III-роторе.

              Класс "EnigmaCipher" содержит один метод:
                  "EnigmaCipher.encrypt_decrypt()". Данный метод не принимает аргументов, вернет строку
                  с расшифрованными или зашифрованными данными.


    Глава III. Геометрические фигуры
        В проекте "Pymath" есть пакет "geometry". Этот пакет содержит инструменты для работы с геометрическими
        фигурами. В этой главе пойдет речь о данном пакете.

        Начнем с файла "shapes.py". Он содержит классы для работы с геометрическими фигурами. Эти классы
        описаны ниже.
            1. "Shape". Данный класс является суперклассом всех классов для двумерных геометрических фигур.
              Данный класс является абстрактным, он нужен только для создания структуры для всех подклассов.
              Создание экземпляра класса происходит следующим образом:
                  my_shape = Shape(58, 49)

              Конструктор класса принимает два аргумента: width - ширина фигуры; height - высота фигуры.
              Данный класс не имеет реализации методов, поэтому создание экземпляра класса "Shape" почти
              не имеет смысла.

            2. "Angle". Данный класс позволяет задать в переменной угол. Так как угол образован двумя лучами,
              он не явяется двумерной фигурой, следовательно класс "Angle" не является подклассом "Shape".
              Создание экземпляра класса происходит следующим образом:
                  my_angle = Angle(15)

              Конструктор класса принимает один аргумент: angle - градусная мера угла (только в градусах).
              При вывединии экзмпляра класса "Angle" на экран, появится строка: "Angle x degrees, sharp",
              где x - градусная мера угла, sharp - тип угла (острый, прямой, тупой, развернутый, вогнутый,
              полный).

              Данный класс имеет один метод:
                  1. "Angle.change_angle()". Данный метод нужен для изменения градусной меры угла. Он
                    принимает один аргумент: new_angle - новая градусная мера угла, заданная по таким
                    же правилам, как и та, что передается в конструктор класса "Angle" (см. выше).

            3. "Line". Данный класс позволяет задать в переменной прямую. Так как прямая не имеет толщины,
              она не является двумерной фигурой, следовательно класс "Line" не является подклассом "Shape".
              Создание экземпляра класса происходит следующим образом:
                  my_line = Line(points={"A": 1.3})

              Конструктор класса принимает один необязательный аргумент: points - словарь, содержащий точки
              на прямой, где ключ - буква точки (заглавная буквва латинского алфавита); значение - число,
              обозначающее координату точки относительно точки 0 на данной прямой.

              У класса "Line" есть следующие методы:
                  1. "Line.add_point()". Данный метод нужен для добавление точки на прямую. Он принимает два
                    аргумента: letter - буква точки (заглавная буква латинского алфавита); x - координата
                    точки (число).
                  2. "Line.remove_point()". Данный метод нужен для удаления точки. Метод принмает один
                    аргумент: letter - буква точки, которую Вы хотите удалить (заглавная буква латинского
                    алфавита).

            4. "Segment". Данный класс позволяет задать в переменной отрезок. Так как отрезок - это часть
              прямой, ограниченная двумя точками, следовательно отрезок, как и прямая, не имеет толщины,
              следовательно не является двумерной фигурой, следовательно класс "Segment" не является
              подклассом "Shape".
              Создание жкземпляра класса происходит следующим образом:
                  my_segment = Segment(15, 16, 28, 41)

              Конструктор класса принимает четыре аргумента: x1 - координата первой точки отрезка по оси OX;
              x2 - координата второй точки отрезка по оси OX; y1 - координата первой точки отрезка по оси OY;
              y2 - координата второй очки отрезка по оси OY.

              У класса "Segment" есть следующие методы:
                  1. "Segment.get_length()". Данный метод не принимает аргументов и нужен для вычисления
                    длины отрезка относительно координат его точек. Вернет числовой объект.
                  2. "Segment.get_center()". Данный метод не принмает аргументов и нужен для вычисления
                    координат середины отрезка. Вернет числовой объект.

            5. "Ray". Данный класс позволяет задать в переменной луч. Так как луч - это геометричекская фигура,
              состоящая из точки и исходящей из нее прямой, следовательно она не имеет толщины, следовательно
              не является двумерной геометрической фигурой, следовательно класс "Ray" не является подклассом
              "Shape".
              Создание экземпляра класса происходит следующим образом:
                  my_ray = Ray(0.398, 6.72)

              Констуктор класса "Ray" принимает два аргумента: x - координата начальной точки луча по оси OX;
              y - координата начальной точки луча по оси OY. Данный класс не имеет методов, за исключением
              служебных.

            6. "Ellipse". Данный класс позволяет задать в переменной эллипс. Эллипс является двумерной фигурой,
              поэтому класс "Ellipse" является подклассом "Shape".
              Создание экземпялра класса происходит следующим образом:
                  my_ellipse = Ellipse(150, 480)

              Конструктор класса "Ellipse" полностью совпадает с конструктором класса "Shape". Он принимает
              два аргумерта: width - ширина прямоугольника, ограничивающего эллипс, то есть один из
              диаметров эллипса; height - высота прямоугольника, ограничивающего эллипс, то есть второй
              диаметр эллипса.

              Класс "Ellipse" имеет следующие методы:
                  1. "Ellipse.area()". Данный метод не принимает аргументов и нужен для вычисления площади
                    эллипса. Вернет числовой объект.
                  2. "Ellipse.perimeter()". Данный метод не принимает аргументов и нужен для вычисления длины
                    эллипса. Вернет числовой объект.
                  3. "Ellipse.point()". Данный метод нужен для вычисления координат точки, лежащей на эллипсе
                    по заданному углу. Он принимает один аргумент: angle - угол, по которому следует вычислять
                    координаты точки. Обратите внимание, что угол следует указывать в радианах. Метод вернет
                    числовой объект.

            7. "Circle". Данный класс позволяет задать в переменной окружность. Так как по сути окружность
              явялется эллипсом с равными диаметрами, класс "Circle" является подклассом "Ellipse" (см. выше).
              Создание экземпляра класса происходит следующим образом:
                  my_circle = Circle(15.39)

              Конструктор данного класса принимает один аргумент: d - диаметр окружности (число).
              Так как класс "Circle" является подклассом "Ellipse", первый наследует все его методы. Помимо
              этого, у класса "Circle" есть дополнительный метод:
                  "Circle.chord()". Данный метод нужен для вычисления длины хорды по центральному углу. Он
                  принимает один аргумент: angle - центральный угол в градусах. Метод вернет числовой
                  объект.

            8. "RegularPolygon". Данный класс позволяет задать в переменной правильный многоугольник.
              Многоугольник является двумерной фигурой, следовательно класс "RegularPolygon" является
              поклассом "Shape".
              Создание экземпляра класса происходит следующим образом:
                  my_polygon = RegularPolygon(150, 8)

              Конструктор класса принимает два аругмента: side_length - длина каждой стороны многоугольника;
              sides - количесво сторон.

              Класс "RegularPolygon" имеет два метода:
                  1. "RegularPolygon.area()". Данный метод не принимает аргументов и нужен для вычисления
                    площади правильного многоугольника. Вернет числовой объект.
                  2. "RegularPolygon.perimeter()". Данный метод не принимает аргументов и нужен для вычисления
                    периметра многоугольника. Вернет числовой объект.

            9. "IrregularPolygon". Данный класс позволяет задать в переменной неправильный многоугольник.
              Многоугольник является двумерной фигурой, следовательно класс "IrregularPolygon" является
              подклассом класса "Shape".
              Создание экземпляра класса происходит следующим образом:
                  my_polygon = IrregularPolygon([[1, 3], [4, 3], [2, 1])  # Неправильный треугольник

              Конструктор класса принимает один аргумент: points - список, содержащий кооринаты вершин
              многоугольника. В этом списке должны содержаться списки с двумя значениями: первое - координата
              вершины по оси OX; второе - координата вершины по оси OY.

              Класс "IrregularPolygon" имеет один метод:
                  "IrregularPolygon.perimeter()". Данный метод не принимает аргументов и нужен для вычисления
                  пери-
                  метра неправильного многоугольника. Вернет числовой объект.

        В файле "impossible_square.py" содержится класс для рисования невозмножных квадратов на холсте Canvas
        модуля tkinter. Этот класс называется "ImpossibleSquare", и о нем пойдет речь в этом разделе.
        Создание экземпляра класса происходит следующим образом:

            root = Tk()  # Создать окно tkinter
            canvas = Canvas(root, width=640, height=480)  # Создать холст Canvas
            my_isquare = ImpossibleSquare(canvas, (50, 50), size=(400, 400, 80),
                                          colors=("red", "pink", "green", "cyan"))  # Создать невозможный квадрат
            canvas.pack()  # Отрисовываем холст на окне
            root.mainloop()  # Выводим на экран окно

        Конструктор класса принимает два обязательных аргумента: canvas - холст Canvas, на котором нужно
        нарисовать невозможный квадрат; coordinates - местоположение левого верхнего угла невозможного
        квадрата на холсте, заданное в виде кортежа, где первое значение - координата по оси OX, второе -
        координата по оси OY.
        Также конструктор класса "ImpossibleSquare" принимает два необязательных аргумента: size - размеры
        невозможного квадрата (x - длина; y - ширина; z - высота), по умолчанию равен (300, 300, 50);
        colors - четыре цвета невозможного квадрата, по умолчанию равен ("grey", "lightgrey", "#3b3b3b", "white").

        Данный класс имеет один метод:
            "ImpossibleSquare.draw()". Данный метод не принимает аргументов и нужен для отрисовки квадрата
            на холсте.

        Примечание. При запуске файла "impossible_square.py" как отдельную программу, будет запущен тест,
        который сначала отрисует один большой невозможный квадрат, а после закрытия пользователем окна с
        квадартом будут отрисованы много маленьких квадратов.

        В файле "plot.py" находятся инструменты для построения графиков. Эти инуструменты описаны ниже.
            1. Класс "Graph". Данный класс нужен для сохранения в переменной формулы, по которой будет
              построен график на координатной плоскости. Создание экземпляра класса происходит следующим
              образом:
                  my_graph = Graph("y=2*x+6", 0, 10, color="green")  # Линейный график

              Конструктор класса принимает три обязательных аргумента: formula - формула графика, first_x -
              начало отсчета оси OX, желательно 0; ox_len - количество делений на оси OY. Также конструктор
              класса принимает один необязательный аргумент: color - цвет линии гарфика, по умолчанию синий.

              Данный класс имеет следующие методы:
                  1. "Graph.create()". Данный метод нужен для отрисовки графика на координатной плоскости. Он
                    принимает один аргумент: canvas - холст Canvas, на котором нужно отрисовать график. Данный
                    метод вызывается внутри класса "Plotter" при отрисовке всех графиков.

            2. Класс "Plotter". Данный класс нужен для отображения координатной плоскости для графиков
              на окне tkinter. Создание экземпляра класса происходит следующим образом:

                  root = Tk()  # Создать окно tkinter
                  my_plotter = Plotter(root, 500, 350, range(1, 11),
                                       range(1, 13), grid=True)  # Создаем координатную плоскость
                  my_plotter.place(x=20, y=18)  # Размещаем плоскость на окне tkinter
                  root.mainloop()  # Выводим на экран окно

              Конструктор класса принимает пять обязательных аргументов: root - окно tkinter, на котом будет
              находиться координатная плоскость с графиками; width - ширина координатной плоскости; height -
              высота координатной прямой; ox - диапазон чисел (range) для нумерации оси OX; oy - диапазон
              чисел для нумерации оси OY. Также конструктор класса "Plotter" принимает один необязательный
              аргумент: grid - нужно ли отображать сетку (True или False), по умолчанию равный True.

              Данный класс имеет следующие методы:
                  1. "Plotter.place()". Данный метод нужен для размещения координатной плоскости на окне. Он
                    принимает два необязательных аргумента: x - координата по оси OX; y - координата по оси OY.
                  2. "Plotter.add_graph()". Данный метод нужен для добавления графика (экземпляра класса "Graph")
                    в список графиков класса "Plotter". Этот список будет использован при отрисовке всех графиков
                    на координатной плоскости. Метод "Plotter.add_graph()" принимает один аргумент: o -
                    экземпляр класса "Graph", который нужно добавить в список.
                  3. "Plotter.remove_graph()". Данный метод нужен для удаления графика из списка. Он принимает
                    один аргумент: id__ - индекс удаляемого графика в списке, начиная с 0.
                  4. "Plotter.clear()". Данный метод нужен для очистки списка графиков. Метод не принимает
                    аргументов.
                  5. "Plotter.enumerate_oxy()". При вызове данного метода произойдет нумерация осей координатной
                    плоскости OX и OY. Метод не принимсает аргументов, вызывается в конструкторе класса
                    "Plotter".
                  6. "Plotter.draw_grid()". Данный метод при вызове нарисует сетку на координатной плоскости.
                    Он не принимает аргументов и вызывается при отрисовке всех графиков, если аргумент "grid" в
                    конструкторе класса "Plotter" равен True.
                  7. "Plotter.plot()". Данный метод нужен для отрисовки всех графиков из списка на координатной
                    плоскости. Метод не принимает аргументов. "Plotter.plot()" отрисует сетку, если аргумент
                    "grid" конструктора класса равен True.

              Примечание. При запуске файла "plot.py" как отдельную программу, будет запущен тест - программа,
              которая будет отрисовывать графики по форумуле, указанной пользователем в поле ввода. При этом,
              если указать в поле ввода формулу, отличную от предыдущей и нажать на кнопку "Построить",
              координатная плоскость будет очищена, и на ней будет построен новый график.

        Файл "pie_chart.py" содержит инструменты для построения круговых диаграмм. Эти инструменты описаны ниже.
            1. Класс "PieChart". Данный класс позволяетс создать на окне tkinter плоскую круговую диаграмму.
              Создание экземпляра класса происходит следующим образом:

                  root = Tk()  # Создаем окно tkinter
                  my_pie_chart = PieChart(380, 100, {"first": 100, "second": 20, "third": 80},
                                                    {"first": "red", "second": "green", "third": "blue"}, root)
                  my_pie_chart.draw(100, 30)  # Отрисовываем диаграмму
                  root.mainloop()  # Запускаем окно

              Конструктор класса принимает пять аргументов: width - ширина или высота области диаграммы
              (она квадратная); radius - радиус круга диаграммы; values - словарь данных для построения
              диаграммы, где ключ - наименование значения диаграммы, значение - числовое значение;
              colors - словарь, содержащий цвета для каждого из данных, где ключ - наименование значения,
              значение - соответствующий ему цвет; master - объект "Tk" (окно tkinter), на котором будет
              постороена диаграмма.

              Класс "PieChart" имеет один метод:
                  "PieChart.draw()". Метод нужен для отрисовки области диаграммы на окне tkinter. Данный метод
                  принимает два аргумента: x - координата области диаграммы на окне tkinter по оси OX;
                  y - координата области диаграммы по оси OY.

            2. Класс "LegendLabel". Данный класс нужен для отображения в области круговой диаграммы одной
              строки ее легенды. Чтобы создать всю легенду, нужно создать несколько экземпляров данного класса
              и отрисовать их. Класс используется внутри класса "PieChart", он малоэффективен при использовании
              его отдельно. Создание экземпляра класса происходит следующим образом:

                  root = Tk()  # Создаем окно tkinter
                  canvas = Canvas(root, width=320, height=240)  # Создаем холст Canvas
                  canvas.pack()

                  my_legend = LegendLabel(canvas, "first - 50.0%", point_color="red")
                  my_legend.draw(5, 10)  # Отрисовывем строку легенды

                  root.mainloop()  # Запуск окна tkinter

              Конструктор класса принимает два обязательных аргумента: canvas - холст Canvas, на котором
              нужно создать строку легенды; text - текст строки. Также конструктор принимает один
              необязательный аргумент: point_color - цвет, соответствующий цвету значения на круговой
              диаграмме, по умолчанию равный "lightblue" (светло-синий).

              Класс "LegendLabel" имеет один метод:
                "LegendLabel.draw()". Данный метод нужен для отрисовки строки легенды на холсте Canvas. Он
                  принимает два аргумента: x - координата по оси OX; y - координата по оси OY.

            Примечание. При запуске файла "pie_chart.py" как отдельную программу, будет запущен тест,
            в котором на окне tkinter будет отображена круговая диаграмма с легендой.


    Глава IV. Встроенные утилиты
        Проект "Pymath" содержит не только пакеты с модулями, но и небольшие приложения. В этой главе описаны эти
        приложения.

        1. Приложение "Часы". Чтобы запустить это приложение, запустите файл "clock.pyw". При запуске, откороется
          окно, где будет отображено текущее системное время в цифровом формате (сверху) и стрелочкные часы с
          циферблатом, часовой, минутной и секундной стрелками (посередине). Стрелочные часы также зависят от
          системного времени.
          В приложении "Часы" внизу также есть кнопка "OVERCLOCK (SPEED x66.7)". При нажатии на эту кнопку часы
          начнут идти в 66.7 раза быстрее обычного так, что минутная стрелка будет идти со скоростью секундной.
          При этом, после нажатия на кнопку, на ней теперь будет написано: "STOP OVERCLOCKING". После того, как
          Вы нажмете на кнопку "STOP OVERCLOCKING", часы снова будут показывать верное системное время и идти
          с обычной скоростью. Данная кнопка - шутка-игра слов: overclock - разгон (процессора), а clock - часы.

        2. Приложение "Текстовый редактор". Внимание! Для того, чтобы приложение "Текстовый редактор" работало
          корректно, требуется наличие встроеннной в Python оболочки IDLE. Чтобы запустить это приложение,
          запустите файл "text_editor.pyw".
          При запуске, откроется окно с большим полем для ввода текста и главным меню вверху. Также внизу есть
          строка состояния с двумя числами, обозначающими текущее положение тектогвого куросора: первое число
          обозначает номер строки, второе - номер столбца.
          В целом, приложение "Текстовый редактор" работает как обычный "Блокнот" из Windows, поэтому я не буду
          заострять на этом внимания. Однако, в этом приложении есть некоторые доплонения:
              1. Возможность сохранения текстового документа в формате PDF. Для этого, в файловом меню
                "Сохранить как ..." в выпадающем списке "Тип файла" выберите пункт "Portable Document Format" и
                нажмите на кнопку "Сохранить".
              2. Раскраска текста. Каждая буква будет раскрашена в определенный цвет. Заметим, что не все символы
                могут быть раскрашены в цвета; те, для которых не задан цвет, останутся черными. Для того, чтобы
                воспользоваться этой функцией, зайдите в главное меню | "Edit", далее выберите пункт "Fun".
                Таже можно найти эту функцию в контекстном меню, которое можно вызвать нажатием правой кнопки
                мыши. Внимание! Чтобы буквы сохранили свои цвета, сохраните файл в формате PDF (см. выше).
              3. Отмена раскраски текста. Раскрашенный текст можно снова сделать черным - для этого зайдите в
                главное меню | "Edit", затем выберите пункт "Normalize". Таже можно найти эту функцию в
                контекстном меню, которое можно вызвать нажатием правой кнопки мыши.
          Горячие клавиши:
              1. Создать новый файл - Ctrl+N
              2. Открыть файл - Ctrl+O
              3. Сохранить файл - Ctrl+S
              4. Сохранить файл как... - Ctrl+Shift+S
              5. Распечатать файл (на принтер по умолчанию) - Ctrl+P
              6. Выйти - Alt+F4
              7. Отменить последнее действие - Ctrl+Z
              8. Повторить последнее действие - Ctrl+Y
              9. Вырезать - Ctrl+X
              10. Копировать - Ctrl+C
              11. Вставить - Ctrl+V
              12. Выделить все - Ctrl+A
              13. Найти - Ctrl+F
              14. Заменить - Ctrl+R
              15. Перейти - Ctrl+G
              16. Вставить текущее время и дату - F5

              Примечание. Для исползования горячих клавиш с буквами латинского алфавита, необходимо переключить
              раскладку на английскую.

          3. Приложение "Графика". В целом, функционально это приложение не отличается от встроенного в ОС Windows
            приложения "Paint", поэтому я не буду подробно рассказывать об этом приложении. Назову только основной
            функционал:
                1. Чтобы нарисовать правильную фигуру (квадрат, круг), зажмите клавишу Left Shift.
                2. Чтобы сохранить рисунок, нажмите на кнопку "Экспорт". Приложение поддерживает два формата дляэ
                  сохранения: в виде PNG-картинки и GD-фалйа (GD - Graphics Drawing). Последний формат поддерживает
                  дальнейшую загрузку в приложение, изменение и повторное сохранение.
                3. Чтобы открыть рисунок, нажмите на кнопку "Импорт". Как говорилось выше, приложение поддерживает
                  открытие только файлов в формате GD.
                4. Приложение "Графика" поддерживает изменение размеров клетки. Чтобы их изменить, нажмите на кнопку
                  "Изменить" в рамке с надписью "Размер клетки". Обратите внимание, что при сохранении в PNG-формат
                  сетка в файле не сохраняется.

          4. Приложение "Графопостроитель". Данное приложение является тестом для модуля "plot" из пакета "geometry".
            При запуске приложения откроется окно с координатной плоскостью и полем ввода для формул. Для того,
            чтобы построить график, введите формулу и нажмите на кнопку "Построить". При этом, формула обязательно
            должна начинаться с "y=", кроме того, нельзя использовать никакие буквы в качестве аргумента, кроме "x".
            Обратите внимание, что если Вы построите график по одной формуле, а затем введете новую формулу и
            нажмете "Построить", то старый график будет удален, а на его месте будет построен новый.


    Глава V. Особенности импорта
        В проекте "Pymath" используется особая система, позволяющая импортировать модули из него. В этой главе
        пойдет речь о том, как правильно импортировать модули из проекта.

        Чтобы импортировать что-либо из модуля из пакета в проекте, Вы можете использовать следующую схему:
            from pymath2.package.module import Class, function,
        где "package" - имя пакета, "module" - имя модуля, "Class, function" - класс, функция и др., что требуется
        импортировать.

        Однако, такой способ импорта, скорее всего, будет полезен в том случае, если Вам понадобится
        использовать какую-либо служебную функцию, класс и т. п. Для того, чтобы быстро импортировать нужный Вам
        инструмент, используйте схему вида:
            from pymath2 import prime_factorization, Angle, Scale,
        где "prime_factorization", "Angle", "Scale" - нужные Вам инструменты.

        Также, как упомяналось в IV главе, проект "Pymath" включает в себя приложения. Их импорт не имеет смысла,
        так как они предназначены для запуска как самостоятельные приложения. Некоторые из них при импорте
        запустятся, но будут работать некорректно.


Спасибо!
