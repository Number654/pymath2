    Проект "Pymath" - это небольшой инструмент, расширяющий встроенные математические инструменты Python.

Обновление 2.0 вышло!

    В этом обновлении:
        1. Исправление багов и ошибок
        2. Улучшен и расширен функционал инструмента
        3. В проект встроены небольшие встроенные приложения,
          такие как стрелочные часы или текстовый редактор
        4. Добавлен новый пакет для геометрических вычислений
    Подробности о новостях обновления 2.0 указаны в файле "whatsnew-ru.txt".


Инструкция по использованию

    Оглавление:
        1. Проверка числа на нечетность - *


    Глава I. Основной функционал
        В проекте "Pymath" главным пакетом является пакет с названием "core".
        Он содержит несколько файлов, о котором в этой главе пойдет речь.

        Начнем с главного файла - "pymath.py", в котором содержится основной
        функционал инструмента. Он содержит следующие функции:
            1. Чтобы узнать, является ли число нечетным, используйте функцию "is_odd()".
              Она принимает один аргумент: num - число, которое вы хотите проверить.
            2. Чтобы узнать, является ли число простым, используйте функцию "is_simple()".
              Она принимает один аргумент: num - число, которое вы хотите проверить.
            3. Чтобы узнать, положительное ли число, используйте функцию "is_positive()".
              Она принимает один аргумент: num - число, которое вы хотите проверить.
            4. Чтобы узнать, злое ли число (https://ru.wikipedia.org/wiki/%D0%97%D0%BB%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE),
              используйте функцию "is_evil()". Она принимает один аргумент: num - число,
              которое вы хотите проверить.
            5. Чтобы перемножить числа из итерируемого объекта, используйте функцию "multiply_all()".
              Она принимает один аргумент: _all - итерируемый объект, содержащий числа, которые Вы хотите
              перемножить.
            6. Чтобы найти кратные какого-либо числа, используйте функцию "multiplies()".
              Она принимает один обязательный аргумент: num - число, кратные которого Вы хотите найти
              и один необязательный: length - нужное Вам количество кратных, по умолчанию равное 10.
            7. Чтобы найти делители числа, используйте функцию "dividers()".
              Она принимает один аргумент: num - число, делители которого Вы хотите найти.
            8. Чтобы найти наименьшее общее кратное (НОК) нескольких чисел, используйте
              функцию "lcm()". Она принимает любое количество аргументов, которыми будут являться
              числа, НОК которых Вы хотите найти.
            9. Чтобы найти наибольший общий делитель (НОД) нескольких чисел, используйте
              функцию "gcd()". Она принимает любое количество аргументов, которыми будут являться
              числа, НОД которых Вы хотите найти.
            10. Чтобы разложить число на простые множители, используйте функцию "prime_factorization()".
              Она принимает один аргумент: num - число, которое вы хотите разложить на простые множители.
              Функция вернет два значения: первое - словарь, в котором содержится результат разложения
              построчно; второе - объект типа "collections.Counter", содержащий количество одинаковых
              простых множителей. Советую использовать функцию "visual_prime_factorization()"
              (см. пункт 11), так как она возвращает в качестве результата строку, содержащую
              более наглядный результат разложения.
            11. Чтобы получить наглядный результат разложения числа на простые множители, используйте
              функцию "visual_prime_factorization()". Она принимает в качестве аргумента результат
              функции "prime_factorization()" (см. пунк 10), преобразуя его в строку, удобную для понимания.
            12. Чтобы представить число в виде суммы разрядных слагаемых, используйте функцию
              "tens_factorization()". Она принимает один аргумент: num - число, которое Вы хотите
              обработать.
            13. Чтобы сгенереировать таблицу степеней в диапазоне натуральных чисел, используйте
              функцию "degree_table()". Она принимает два аргумента: degree - показатель
              степени, в которую следует возводить каждое из чисел таблицы; _range - диапазон целых
              чисел, которые следует использовать в таблице.
            14. Чтобы найти среднее арифметическое нескольких чисел, используйте функцию "average()".
              Она принимает один аргумент: nums - итереруемый объект, содержащий числа, среднее
              арифметическое которых Вы хотите найти.
            15. Чтобы найти корень числа n-ой степени, используйте функцию "root()". Она
              принимает один обязательный аргумент: x - число, корень которого Вы хотите найти
              и один необязательный: n - показатель корня, по умолчанию равный 2.
            16. Чтобы найти арккотангенс числа, используйте функцию "arcctg()". Она принимает
              один аргумент: x - число, арккотвангенс которого Вы хотите найти.
            17. Чтобы выполнить деление с остатком, используйте функцию "better_divmod()".
              Она принимает два аргумента: x - делимое; y - делитель. Данная функция была создана,
              чтобы заменить встроенную функцию "divmod()", так как последняя округляля результат
              деления, чтобы получить цело число, вместо того, чтобы отсечь дробную часть результата.
            18. Чтобы найти среднее геометрическое нескольких чисел, используйте функцию "geometric_mean()".
              Она принимает один аргумент: nums - итереруемый объект, содержащий числа, среднее
              геометрическое которых Вы хотите найти.

        Файл "fractions.py" содержит инструменты для работы с обыкновенными дробями. В данном
        файле содержатся классы, а также некоторые функции. Начнем с классов:
            1. Класс "Fraction". Данный класс нужен, чтобы сохранить в переменной обыкновенную дробь.
              Создание экземпляра класса происходит следующим образом:
                  my_fraction = Fraction("5&2/3")
                Сначала идет целая часть (если есть), затем ставится знак "&", затем идет числитель
              дроби, после него стоит знак "/", в конце идет знаменатель дроби.
                С экземпляром класса можно производить все арифметические действия, а также
              возведение в степень с целым показателем. Кроме того, у класа "Fraction" есть
              следующие методы:
                  1. "Fraction.is_mixed_number()". Данный метод вернет True, если дробь является
                    смешанным числом (имеет целую часть).
                  2. "Fraction.is_improper()". Данный метод вернет True, если дробь является
                    неправильной.
                  3. "Fraction.is_typical()". Данный метод вернет True, если дробь не является
                    ни смешанным числом, ни неправильной дробью.
                  4. "Fraction.is_contract()". Данный метод вернет True, если дробь можно сократить.
                  5. "Fraction.format_to_improper_fraction()". Данный метод нужен, чтобы преобразовать
                    смешанное число в неправильную дробь. В случае, если дробь не смешанное число
                    или уже является неправильной, метод вернет копию дроби, которую Вы пытались
                    преобразовать.
                  6. "Fraction.format_to_mixed_number()". Данный метод нужен, чтобы преобразовать
                    неправильную дробь в смешанное число. В случае, если дробь уже смешанное число
                    или не является неправильной, метод вернет копию дроби, которую Вы пытались
                    преобразовать.
                  7. "Fraction.reduce()". При вызове данного метода произойдет сокращение дроби
                    до несократимой.
                  8. "Fraction.reverse()". Метод вернет дробь, обратную данной.
                  9. "Fraction.to_decimal()". Данный метод нужен, чтобы привести обыкновенную дробь
                    к десятичному знаменателю. При этом, если дробь невозможно обратить в десятичную,
                    метод вызовет исключение ValueError.
                  10. "Fraction.is_translatable_to_decimal()". Данный метод вернет True, если дробь
                    можно обратить в десятичную.
                  11. "Fraction.format_sign()". Данный метод служебный. Он вызывается в конструкторе
                    класса "Fraction", чтобы упростить знаки в числителе и знаменателе дроби. Например,
                    если и в числителе, и в знаменателе дроби отрицательные числа, то после упрощения
                    дробь будет положительной.
                Так же данный класс поддерживает переведение в тип int. Для этого нужно вызвать
              встроенную функцию int() и передаеть ей экземпляр класса "Fraction". При вызове данной
              функции произойдет отсечение дробной части.

            2. Класс "LiteralFraction". Данный класс нужен, чтобы сохранить в переменной
              обыкновенную дробь, числитель и/или знаменатель которой являются буквенными
              выражениями.
              Создание экземпляра класса происходит следующим образом:
                  my_fraction = LiteralFraction(("2a+5.5b", "6c-8a"))
                  В конструктор класса предается список или кортеж, в котором первый объект -
                строка, содержащая числитель дроби; второй - строка, содержащая знаменатель дроби.
                  Внимание! Данный класс не поддерживает смешанные числа.
              Данный класс не поддерживает арифметические действия. Числитель класса сохранен
              в переменной экземпляра "my_fraction.numerator", знаменатель в "my_fraction.denominator".
              Изменяя эти переменные, Вы изменяете выражения в дроби. Кроме того, в классе есть
              методы, позволяющие производить конкатенацию выражений:
                  1. "LiteralFraction.append_to_numerator()". Данный метод производит конкатенацию
                    выражений в числителе дроби и принимает один аргумент: string - буквенное
                    выражение, которое Вы хотите присоединить к выражению в числителе.
                  2. "LiteralFraction.append_to_denominator()". Данный метод производит конкатенацию
                    выражений в знаменателе дроби и принимает один аргумент: string - буквенное
                    выражение, которое Вы хотите присоединить к выражению в знаменателе.

            3. Класс "Double". Данный класс позволяет использовать числа с плавающей точкой
              большей точности. Ограничителями точности являются объем оперативной памяти и
              мощность процессора.
              Создание экземпляра класса происходит следующим образом:
                  my_fraction = Double("3.14159265358979323846")
                  В конструктор передается один аргумент: строка, содержащая десятичную дробь.
                Обратите внимание, что целая часть числа от дробной отделяется только точкой.
              Данный класс поддерживает все арифметические действия, так же, как и класс
              "Fraction". Ниже перечислены некоторые другие методы класса "Double":
                  1. "Double.round()". Данный метод округляет десятичную дробь до
                    нужной точности и принимает одини необязательный аргумент: accuracy - точность,
                    до которой следует округлять, по умолчанию - до целых. Округление происходит так
                    же, как и в случае со встроенным методом round(), о котором можно приочитать в
                    документации Python.
                Так же данный класс поддерживает переведение в тип int. Для этого нужно вызвать
              встроенную функцию int() и передаеть ей экземпляр класса "Double". При вызове данной
              функции произойдет отсечение дробной части.
                Так же есть возможность перевести тип "Double" в тип float. Для этого нужно вызвать
              встроенную функцию float() и передать ей ээкземпляр класса "Double". Внимание! При
              переведении в тип float возможна потеря точности.

            4. Класс "PeriodicFraction". Данный класс позволяет работать с периодическими дробями.
               Создание экземпляра класса происходит следующим образом:
                   my_fraction = PeriodicFraction("1.(3)")
                   В конструктор передается один аругмент: строка, содержащая периодическую дробь.
                 При этом, перед точкой стоит целая часть, затем точка, после нее идут цифры до периода
                 (если они есть), затем, в скобках стоят цифры в периоде.
                   Обратите внимание, что целая часть от дробной отделяется только точкой.
               Данный класс не поддерживает арифметические действия, однако, есть возможность перевести
               периодическую дробь в обыкновенную, и с ней производить арифметические действия. Ниже
               перечислены методы класса "PeriodicFraction":
                   1. "PeriodicFraction.to_ordinary()". Данный метод не принимает аргументов. Нужен
                     для переведения периодической дроби в обыкновенную. При вызове вернет экземпляр
                     класса "Fraction", содержащий результат переведения.
                   2. "PeriodicFraction.is_clean()". Данный метод вернет True, если периодическая
                     дробь является чистой, то есть не содержит цифр перед периодом.

        Также файл "fractions.py" содержит несколько функций для работы с дробями:
           1. Чтобы узнать, содержит ли строка число с плавающей точкой, используйте функцию "isfloat()".
             Она принимает один аргумент: string - строка, которую Вы хотите проверить. Функция вернет True,
             если строка содержит число с плавающей точкой.
           2. Чтобы преобразовать целое число (int) в обыкновенную неправильную дробь, используйте функцию
             "int2fraction()". Она принимает один аргумент: integer - целое число, которое Вы хотите
             преобразовать.
           3. Чтобы преобразовать число с плавающей точкой (float) в обыкновенную дробь, используйте функцию
             "float2ordinary()". Она принимает один аргумент: _float - число с плавающей точкой, которое
             Вы хотите преобразовать.
           4. Чтобы перобразовать список строк, содержащих дроби в список дробей типа "Fraction",
             используйте функцию "strings_list2fractions_list()". Она принимает один аргумент: my_list -
             итерируемый объект, в том числе список, который Вы хотите преобразовать. Обратите внимание,
             что строки в списке для преобразования должны иметь такую же структуру, как и те, что Вы
             передаете в конструктор класса "Fraction" (см. страницу ***).
           5. Чтобы преобразовать целое число (int) или число с плавающей точкой (float) в обыкновенную
             дробь, используйте функцию "to_fraction()". Данная функция по сути совмещает алгоритмы из функций
             "int2fraction()" и "float2ordinary()". Она принимает один аргумент: __obj - число, которое
             Вы хотите преобразовать. Если в качестве аргумента будет передан тип "Fraction", то есть не
             требующая преобразования обыкновенная дробь, функция вернет ее. Если аргумент не будет
             являться ни типом int, ни float, ни "Fraction", функция вернет None.
           6. Чтобы привести дроби к наименьшему общему знаменателю, используйте функцию
             "reduce_to_common_denominator()". Она принимает один аругмент: my_fractions - итерируемый
             объект, содержащий обыкновенные дроби ("Fraction"). Данная функция вернет список дробей с
             наименьшим общим знаменателем.
           7. Чтобы отсортировать список обыкновенных дробей, используйте функцию "sort_fractions()".
             Она принимает один обязательный аргумент: my_fractions - итерируемый объект, содержащий
             обыкновенные дроби ("Fraction"); и один необязвательный: reverse - аргумент, обозначающий
             порядок сортировки: True - по убыванию, False - по возрастанию; по умолчанию равный False.
             Данная функция вернет список отсортированных в заданном порядке обыкновенных дробей.
           8. Чтобы решить короткое выражение с обвкновенными дробями в строке, используйте функцию
             "solve_fraction_expr()". Она принимает один аргумент: expr - строка, содержащая выражение.
             Обратите внимание, что все обыкновенные дроби должны быть отделены от знаков арифметических
             действий пробелами и иметь такую же структуру, как строки, передаваемые в конструктор класса
             "Fraction" (см. страницу ***). Важно! Данная функция не поддерживает выражения со вложенными
             скобками.

        Файл "equations.py" содержит инструменты для работы с уравнениями. В данном фале находятся классы
        для решения уравнений и систем уравнений, перечисленные ниже:
            1. Класс "SuperSymbol". Данный класс нужен, чтобы сохранить в переменной неизвестную букву,
              затем произвести арифметические действия с ней, а затем решить. Это происходит следующим
              образом:
                  a = SuperSymbol(symbol="a")
                  a = 8-(2*a*5+3)
              Конструктор данного класса принимает один необязательный аргумент: symbol - буква,
              которую Вы хотите использовать в уравнении (по умолчанию "x").

              У данного класса, помимо методов для выполения арифметических действий есть и другие методы,
              перечисленные ниже:
                  1. "SuperSymbol.can_solve()". Данный принимает один аргумент: z - правая часть уравнения
                    (это может быть число или другой экзкмепляр класса SuperSymbol) и вернет True, если
                     у уравнения есть хотя бы одно решение.
                  2. "SuperSymbol.get()". Данный метод принимает один аргумент: z - правая часть уравнения.
                    При этом, если в качестве аргумента передать другой экземпляр класса SuperSymbol,
                    произойдет перенос слагаемых, а затем решения уравнения. Если у уравнения не окажется
                    решений, метод вернет None.
                  3. "SuperSymbol.post_symbol()". Данный метод принимает один аргумент: n - число, которое
                    нужно подставить вместо неизвестного в уравнении. Данный метод нужен для решения
                    числового выражения, которое получится при подстановки числа n в левую часть уравнения
                    вместо неизвестного.

              Внимание! Класс "SuperSymbol" является суперклассом всех классов для решения уравнений.
              Это означает, что у все подклассы будут устроены подобным этому классу образом.
              Так как подклассами данного класса являются линейные и дробные уравнения, в самом
              суперклассе не находятся алгоритмы их решения. Напрмер, в методе "SuperSymbol.get()"
              реализован только алгоритм переноса слагаемых. После выполнения этого алгоритма, метод
              передаст управление метлду из подкласса, который, в ссвою очередь, произведет решение
              уравнения. Если же перенос слагаемых не потребовался, метод веренет строку "continue",
              получив котороую, метод решения уравнения из подкласса выполнит это действие.
              Также в методе суперкласса "SuperSymbol.post_symbol()" отсутствует рализация, метод
              переопределен в подклассах и реализован.

            2. Класс "LinearSymbol". Данный класс является подклассом "SuperSymbol" (см. пункт 1). Он
              нужен для решения линейных уравнений. Создание экземпляра класса происходит
              так же, как и у "SuperSymbol":
                  a = SuperSymbol(symbol="a")
                  a = 8-(2*a*5+3)

              Как говорилось в пункте 1, "LinearSymbol" и другие подклассы имеют те же методы, что и
              "SuperSymbol". Это означает, что данным классом нужно пользоваться так же, как и классом
              "SuperSymbol".

            3. Класс "FractionalSymbol". Данный класс является подклассом "SuperSymbol" (см. пункт 1).
              Он нужен для решения дробных уравнений (в которых неизвестное в знаменателе). Создание
              экземпляра класса проичходит так же, как и у "SuperSymbol":
                  a = SuperSymbol(symbol="a")
                  a = 8-(2*a*5+3)

              Как говорилось в пункте 1, "LinearSymbol" и другие подклассы имеют те же методы, что и
              "SuperSymbol". Это означает, что данным классом нужно пользоваться так же, как и классом
              "SuperSymbol".

            4. Класс "Symbol". Данный класс является подклассом "SuperSymbol" (см. пункт 1). Он нужен
              для решения уравнений неопределенного вида (вид может переходить из линейного в дробный
              и обратно в процессе арифметических действий). Создание экзмемпляра класса происходит
              так же, как и y "SuperSymbol":
                  a = SuperSymbol(symbol="a")
                  a = 8-(2*a*5+3)

              Как говорилось в пункте 1, "LinearSymbol" и другие подклассы имеют те же методы, что и
              "SuperSymbol". Это означает, что данным классом нужно пользоваться так же, как и классом
              "SuperSymbol".

            5. Класс "SuperDoubleSymbol". Данный класс нужен для работы с уравнениями, в которых неизвестны
              два числа и используются в системах уравнений. Данный класс является подклассом "Symbol".
              Заметим, что суперклассом для "SuperDoubleSymbol" выбран именно класс "Symbol", так как
              не требуется определение вида уравнения.
              Создание экзмепляра класса происходит следующим образом:
                  eq = SuperDoubleSymbol(sub=True, symbol1="p", symbol2="q")
                  eq = 9-(2*eq+6-8*(eq-1))

              Конструкор класса "SuperDoubleSymbol" принимает три необязательных аргумента: sub - True,
              если нужно вычитать два неизвестных (второе из первого), по умолчанию False; symbol1 -
              буква, которой Вы хоите обозначить первое неизвестное, по умолчанию "x"; symbol2 - буква,
              которой Вы хотите обозначить второе неизвестное, по умолчанию "y".

              Класс "SuperDoubleSymbol" поддерживает арифметические действия, однако, если Вы попытаетесь
              вызвать метод "SuperDoubleSymbol.get()", он вызоыет исключение TypeError, так как уравнения
              с двумя неизвестными нельзя решить по отдельности - они используются только в системе
              уравнений.

              Внимание! Класс "SuperDoubleSymbol" является суперклассом всех классов для работы с
              уравнениями с двумя неизвестными. Это означает, что все его подклассы будут устроены
              подобным этому классу образом.

            6. Класс "DoubleSymbol". Данный класс является подклассом "SuerDoubleSymbol" (см. пункт 5).
              Он нужен для работы с уравнениями, в которых неизвестны два числа. Как говорилось в пункте
              выше, такие уравнения нельзя решить отдельно от системы уравнений. Создание экземпляра
              класса происходит следующим образом:
                  eq = DoubleSymbol(5, sub=True, symbol1="p", symbol2="q")
                  eq = 9-(2*eq+6-8*(eq-1))

              Конструктор класса принмает, помимо аргументов его суперкласса, обязательный аргумент
              z - правая часть уравнения (число).

              У данного класса есть 1 метод:
                  "DoubleSymbol.express_x()". Данный метод не принимает аргументов и нужен, чтобы выразить
                  первое неизвестное из уравнения. Метод вернет экземпляр класса "Symbol" - уравнение с
                  одним неизвестным, которое будет иметь букву аторого неизвестного.

            7. Класс "TwoSidedDoubleSymbol". Данный класс является подклассом "SuperDoubleSymbol"
              (см. пункт 5). Он нужен для работы с уравнениями, в которых неизвестны два числа, но
              с возможностью переноса слагаемых (только если в уравнении в обеих частях неизвестные).
              Для таких уравнений создан отдельный класс системы уравнений, о чем будет написано в
              следующих пунктах.

              Создание экземпляра класса происходит следующим образом:
                  eq = TwoSidedDoubleSymbol(sub=True, symbol1="p", symbol2="q")
                  eq = 9-(2*eq+6-8*(eq-1))

              Данный класс, в отличие от "DoubleSymbol" не имеет метода "express_x()". Так как в
              обеих частях такого уравнения находятся неизвестные, перенос слагаемых отдельно от
              системы уравнений осуществить не получится. Это происходит сразу при решении системы
              уравнений. Также, в классе "TwoSidedDoubleSymbol" не нужно сразу передавать правую
              часть, так как в конструктор класса для решения систем уравнений с перенеосом слагаемых
              передаются кортежи с двумя экземплярами класса "TwoSidedDoubleSymbol": один - левая часть;
              второй - правая.

            8. Класс "EqSystem". Данный класс нужен для решения систем уравнений. Создание экземпляра
              класса происходит следующим образом:
                eq1 = DoubleSymbol(7, sub=False, symbol1="x", symbol2="y")
                eq1.k2 = 5  # Коэффициент второго неизвестного теперь равен 5

                eq2 = DoubleSymbol(4, sub=True, symbol1="x", symbol2="y")
                eq2.k, eq2.k2 = (3, 2)  # Коэффициенты 1 и 2-го неизвестных равны 2 и 3 соответственно

                eq_system = EqSystem(eq1, eq2)

              Сначала нужно создать два экземпляра класса "DoubleSymbol", затем передать их в
              конструктор класса "EqSystem". Важно! Чтобы задать нужные коэффициенты неизвестным,
              обращайтесь к переменным экземпляра: k - коэффициент первого неизвестного; k2 -
              коэффициент второго неизвестного (по умолчанию все коэффициенты равны 1).

              У данного класса есть 1 метод:
                  "EqSystem.get()". Данный метод не принимает аргументов и нужен, чтобы решить систему
                  уравнений. Вернет словарь, в котором ключом является буква неизвестного, значением -
                  значение неизвестного.

            9. Класс "TransferEqSystem". Данный класс является подклассом класса "EqSystem" и нужен
              для решения систем уравнений с предварительным переносом слагаемых в этих уравнениях.
              Создание экземпляра класса происходит следующим образом:
                eq1_left = 3*TwoSidedDoubleSymbol(sub=True, symbol1="x", symbol2="y")
                eq1_left = eq1_left + 5*Symbol("x")  # Левая часть первого уравнения
                eq1_right = 2*(3*Symbol("x")-2)  # Правая часть первого уравнения

                # Левая часть второго уравнения
                eq2_left = 4*Symbol("x") - 2*TwoSidedDoubleSymbol(sub=False, symbol1="x", symbol2="y")
                eq2_right = 4 - 3*Symbol("y")  # Правая часть второго уравнения

                eq_system = TransferEqSystem((eq1_left, eq1_right), (eq2_left, eq2_right))

              В конструктор класса "TransferEqSystem" передается два кортежа, содержащих левую
              и правую часть уравнений.

              Данный класс имеет 1 метод:
                  "TransferEqSystem.get()". Данный метод не принимает аргументов и нужен для решения
                  системы уравнений. При вызове произойдет перенесение слагаемых в обоих уравнениях,
                  результатом будут уравнения с неизвестными только в левой части (экземпляры класса
                  "DoubleSymbol"), после этого на основе полученных данных будет создан экземпляр
                  класса "EqSystem" и выполнено решение системы уравнений. Метод вернет словарь,
                  в котором ключом является буква неизвестного, значением - значение неизвестного.
